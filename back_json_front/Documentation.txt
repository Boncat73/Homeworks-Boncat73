Технічна документація: Fullstack JSON-додаток
Цей проект демонструє архітектуру клієнт-сервер, 
де фронтенд і бекенд повністю розділені, а зв'язувальною 
ланкою виступає формат JSON.

1. Архітектурна схема (Data Flow)
Взаємодія відбувається за циклом "Запит — Відповідь" 
(Request-Response):Фронтенд 
(JS): Збирає дані з форми -> Перетворює об'єкт JS у JSON-рядок -> Надсилає HTTP-запит.
Бекенд (Flask): Приймає JSON -> Перетворює його на об'єкт Python -> Зберігає в БД.
База даних (Postgres): Надійно зберігає дані в таблицях.
Зворотний шлях: Flask дістає дані з БД -> Перетворює на JSON-масив -> Надсилає клієнту -> JS "малює" HTML.

2. Детальний розбір JSON-обмінуJSON (JavaScript Object Notation) — 
це текстовий формат, який розуміють і Python, і JavaScript.А. 
Реєстрація користувача (POST)Коли клієнт надсилає дані, пакет виглядає так:
JSON{
  "username": "Ivan",
  "email": "ivan@example.com",
  "password": "hashed_string",
  "age": 25,
  "city": "Kyiv"
}
На стороні JS: Ми використовуємо JSON.stringify(formData), щоб перетворити об'єкт у цей текст.
На стороні Flask: Ми використовуємо request.get_json(), 
щоб перетворити цей текст назад у словник (dictionary) Python.
Б. Отримання списку (GET)Бекенд повертає масив об'єктів (список):
JSON[
  {"id": 1, "username": "Ivan", "city": "Kyiv"},
  {"id": 2, "username": "Oleg", "city": "Lviv"}
]
На стороні Flask: Функція jsonify(user_list) автоматично додає заголовок Content-Type: application/json.
На стороні JS: Метод response.json() розпаковує цей текст у масив, з яким можна працювати через .forEach().

3. Специфікація API (Ендпоінти)МетодШляхОписФормат данихGET/Завантаження головної сторінкиHTML/CSS/JSPOST/register
Створення нового користувачаJSON (вхід)GET/users
Отримання всіх користувачівJSON (вихід)DELETE/delete_user/<id>
Видалення запису за IDURL параметр.

4. Рівень бази даних (ORM SQLAlchemy)Ми не пишемо чистий SQL (на кшталт INSERT INTO...), 
а використовуємо ORM (Object-Relational Mapping). 
Це дозволяє працювати з рядками таблиці як з об'єктами класів Python.
Модель: Клас User визначає структуру таблиці.
Синхронізація: Команда db.create_all() автоматично створює таблиці в PostgreSQL, якщо їх ще немає.
Локаль: Через використання PostgreSQL 16+, база створена з провайдером icu або libc для коректного сортування тексту.

5. Клієнтська логіка (DOM Manipulation)JavaScript виконує роль "художника". 
Він не перезавантажує сторінку повністю (це принцип AJAX), 
а лише оновлює частину інтерфейсу:Створення елементів: document.createElement('li').
Наповнення даними: Використання ключів JSON (наприклад, user.username).
Вставка в дерево: appendChild().

6. Безпека та Хешування (Security Aspect)
У проекті використана бібліотека werkzeug.security для обробки паролів. 
Це забезпечує захист даних навіть у випадку, якщо зловмисник отримає доступ до самої бази даних.

Як це працює в коді:
Хешування при реєстрації: Коли користувач вводить пароль (наприклад, 12345), 
функція generate_password_hash перетворює його на довгий нечитабельний рядок (хеш), 
наприклад: pbkdf2:sha256:600000$xyz....

Зберігання: У таблицю user у колонку password записується саме цей хеш, а не реальний пароль.

Принцип "Незворотності": Хеш неможливо розшифрувати назад у пароль. 
Його можна лише порівняти з новим введеним паролем під час входу.

Чому це важливо для JSON:
Ми ніколи не відправляємо поле password у нашому маршруті GET /users. 
Якщо подивитись на app.py, у списку, який ми віддаємо фронтенду, 
є лише username, age та city. Пароль залишається "секретом" сервера.